import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.pylab as pylab
import jdc
from ExerciseAnswers import Answers


class CoaxialCopter:

    def __init__(self,
                 k_f=0.1,  # value of the thrust coefficient
                 k_m=0.1,  # value of the angular torque coefficient
                 m=0.5,  # mass of the vehicle
                 i_z=0.2,  # moment of inertia around the z-axis
                 ):
        self.k_f = k_f
        self.k_m = k_m
        self.m = m
        self.i_z = i_z

        self.omega_1 = 0.0
        self.omega_2 = 0.0
        self.g = 9.81

    @property
    def z_dot_dot(self):
        """Calculates current vertical acceleration."""

        # TODO:
        # 1. Calculate the lift force generated by the first
        #    and second propellers
        # 2. Calculate the total vertical force acting on the drone
        # 3. Calculate the vertical acceleration due to the
        #    total force acting on the drone keep in mind that the
        #    z-axis is directed downward
        return self.g - (self.k_f / self.m) * (self.omega_1 ** 2 + self.omega_2 ** 2)

    @property
    def psi_dot_dot(self):
        """Calculates current rotational acceleration."""

        # TODO:
        # 1. Calculate the torques generated by both propellers
        # 2. Calculate the angular acceleration
        return (self.k_m / self.i_z) * (-(self.omega_1 ** 2) + self.omega_2 ** 2)

    def set_rotors_angular_velocities(self, linear_acc, angular_acc):
        """
        Sets the turn rates for the rotors so that the drone
        achieves the desired linear_acc and angular_acc.
        """

        # TODO
        # 1. Calculate the correct values of omega_1 and omega_2
        # 2. Set self.omega_1 and self.omega_2 to those values
        # 3. Don't forget to return omega_1, omega_2
        # Reminder: The second propeller rotates counterclockwise
        # thus the angular velocity needs to be positive,
        # while angular velocity of the first propeller needs to be
        # negative as it rotates clockwise.

        self.omega_1 = -np.sqrt(
            0.5 * (self.m / self.k_f) * (self.g - linear_acc) - 0.5 * (self.i_z / self.k_m) * angular_acc)
        self.omega_2 = np.sqrt(
            0.5 * (self.m / self.k_f) * (self.g - linear_acc) + 0.5 * (self.i_z / self.k_m) * angular_acc)
        return self.omega_1, self.omega_2
